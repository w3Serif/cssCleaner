var common_lib	= require('./commonLib');

var CompareCSSClasses = (function(){

	function CompareCSSClasses(obj, usedCss){
		this.obj = obj;
		this.key = 0;

		this.usedCSS = usedCss;
		this.comparedObj = {};

		this._rule_str  = '';
		this._rule_subs  = [];

		this.keySlider();
	}

	CompareCSSClasses.prototype = {
		constructor: CompareCSSClasses,
		keySlider: function(){
			for(this.key in this.obj){
				// каждое правило бьем на подправила по запятым
				var arr = this.key.split(',');
				var newSelector = [];
				var newRule = this.obj[this.key];

				for (var i=0; i<arr.length; i++) {
					var isValid = this.parseSingleRule(arr[i]);

					if (isValid === true) {

						newSelector.push(arr[i]);
						newRule = newRule.trim();
					}
					if (typeof isValid == 'string'){
						newSelector.push(this._rule_str);
						// media
						if (typeof this.obj[this.key] == 'object'){
							newRule = new CompareCSSClasses(this.obj[this.key], this.usedCSS).comparedObj;
						}

						if (isValid == '@keyframes'){
							newRule = newRule.trim();
						}
//							console.log(this._rule_str, this.obj[this.key]);

					}

				}

				if (newSelector.length>0) {
					newSelector = newSelector.toString();
//						console.log(this.obj[this.key]);
					this.comparedObj[newSelector] = newRule;
				}

			}
//				console.log('new',this.comparedObj);
		},
		_class_checkDouble: function(substr){
			var subs = substr || this._rule_subs;
			for (var s=0; s<subs.length; s++){
//					console.log(subs, subs[s]);
				var e = subs[s].match(/(\.[\w\-\_\d]*)/g);
				if (e && e.length>1) subs[s] = e;
			}
			if (substr) return subs;
			else this._rule_subs = subs;
		},
		_class_checkAttr: function(substr){
			var subs = substr || this._rule_subs;
			var errStrFix ='';
			for (var s=0; s<subs.length; s++){
				var errstr = subs[s].match(/\[/);
				if (errstr) {
					for (var h=s, j=0; j<3; j++, h++){
						errStrFix+=subs[h];
						subs[h] = ':::'
					}
					subs[s] = errStrFix;
					errStrFix = '';
				}
			}
			if (substr) return subs;
			else this._rule_subs = subs;
		},
		_compare_classes: function(){
			for (var s=0; s<this._rule_subs.length; s++){
//							console.log('s',subs, subs[s]);
				if (this._rule_subs[s]!=':::'){
					if (typeof this._rule_subs[s] == "string") {
						if (this._rule_subs[s].match(/\./)) {
//										console.log(common_lib.isWordInArray(subs[s], this.usedCSS), subs[s]);
							if (!common_lib.isWordInArray(this._rule_subs[s], this.usedCSS)) {
//											console.log(subs, subs[s],false);
								return false;
							}
						}
					} else {
						for (var i=0;i<this._rule_subs[s].length;i++){
//										console.log(common_lib.isWordInArray(subs[s][i], this.usedCSS), subs[s][i]);
							if (!common_lib.isWordInArray(this._rule_subs[s][i], this.usedCSS)) {
//									console.log(this._rule_subs, this._rule_subs[s][i],false);
								return false;
							}
						}
					}
				}
			}
			return true;

		},
		parseSingleRule: function(singleRule){
			this._rule_str = singleRule.trim();
//				console.log(this._rule_str);
			var compositePat = /([\~\s\+\>]+)/g;
			var isComposite = this._rule_str.match(compositePat);

			var anyMedia = this._rule_str.match(/@/);
			var mediaType = '';
			if (anyMedia) mediaType = common_lib.getMediaType(anyMedia.index, this._rule_str);

			if (!anyMedia) {

				if (isComposite) {
//						console.log('isComposite:',this._rule_str);
					this._rule_subs = this._rule_str.split(compositePat).map(function(x){return x.trim()});

					// проверяем на разбение подправил [attr~=...] и фиксим
					this._class_checkAttr();

					// проверяем на сдвоенные классы и переделываем массив
					this._class_checkDouble();

					//2. сопоставление слов если нет в наборе - гудбай
					return this._compare_classes();
				}
				/*
				 * SINGLE CLASS RULE
				 * */
				else {
					// если есть класс - реагируем
					var single_rul;
					if (this._rule_str.match(/\./g)){
						single_rul = this._rule_str.match(/(\.[\w\-\_\d]+)/g);

						var jtlen = single_rul.length;
						for (var i=0; i<jtlen; i++){
							// сопоставление слов если нет в наборе - гудбай
//								console.log(common_lib.isWordInArray(single_rul[i], this.usedCSS), single_rul[i]);
							if (!common_lib.isWordInArray(single_rul[i], this.usedCSS)) return false;
						}
						return true;
					}
					// если нет точек - значит элемент.
					else return true;
				}
			}
			else {
				return mediaType;
			}

		},
		slicer: function(buffer, cursor){
			var v = this._rule_str.slice(buffer,cursor);
//				this.bCur = this.cur+1;
			return v;
		}

	};

	return CompareCSSClasses;
})();

module.exports = CompareCSSClasses;